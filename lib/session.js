// Generated by CoffeeScript 1.4.0
(function() {
  var Cookie, cookieSession, crypto, decrypt, decryptCookie, encrypt, encryptCookie, hashPayload, hashVerify, newSession, sigSplitter, uuid, validateTS,
    __slice = [].slice;

  crypto = require('crypto');

  Cookie = require('cookie');

  uuid = require('node-uuid');

  sigSplitter = '~';

  newSession = function(ts) {
    if (ts == null) {
      ts = (new Date()).getTime();
    }
    return {
      id: uuid.v4(),
      ts: ts
    };
  };

  validateTS = function(obj, duration) {
    var ts;
    ts = (new Date()).getTime();
    if (obj.ts) {
      if ((duration * 1000) > ts - obj.ts) {
        obj.ts = ts;
        return obj;
      } else {
        return newSession(ts);
      }
    } else {
      return newSession(ts);
    }
  };

  decrypt = function(encrypted, type, secret, duration) {
    var buffer, decipher;
    try {
      buffer = [];
      encrypted = encrypted.replace(/_/g, '=').replace(/-/g, '/');
      decipher = crypto.createDecipher(type, secret);
      buffer.push(decipher.update(encrypted, 'base64', 'utf8'));
      buffer.push(decipher.final('utf8'));
      return validateTS(JSON.parse(buffer.join('')), duration);
    } catch (e) {
      return newSession();
    }
  };

  hashPayload = function(payload, secret) {
    var hmac;
    hmac = crypto.createHmac('sha1', secret);
    hmac.update(payload + secret + payload);
    return hmac.digest('hex');
  };

  hashVerify = function(payload, secret, hash) {
    var digest;
    digest = hashPayload(payload, secret);
    return digest === hash;
  };

  decryptCookie = function(encrypted, type, secret, duration) {
    var payload, sig, _ref;
    _ref = encrypted.split(sigSplitter), payload = _ref[0], sig = _ref[1];
    if (hashVerify(payload, secret, sig)) {
      return decrypt(payload, type, secret, duration);
    } else {
      return newSession();
    }
  };

  encrypt = function(obj, type, secret) {
    var buffer, cipher, payload, res;
    buffer = [];
    payload = JSON.stringify(obj);
    cipher = crypto.createCipher(type, secret);
    buffer.push(cipher.update(payload, 'utf8', 'base64'));
    buffer.push(cipher.final('base64'));
    res = buffer.join('');
    return res.replace(/\=/g, '_').replace(/\//g, '-');
  };

  encryptCookie = function(obj, type, secret) {
    var hash, payload;
    payload = encrypt(obj, type, secret);
    hash = hashPayload(payload, secret);
    return payload + sigSplitter + hash;
  };

  cookieSession = function(options) {
    var cookieOptions, duration, key, noEncrypt, secret, type, _ref;
    _ref = options || {}, key = _ref.key, secret = _ref.secret, type = _ref.type, duration = _ref.duration, noEncrypt = _ref.noEncrypt;
    cookieOptions = (options != null ? options.cookie : void 0) || {
      path: '/'
    };
    noEncrypt || (noEncrypt = false);
    key || (key = 'authme');
    type || (type = 'aes192');
    duration || (duration = 2 * 7 * 86400);
    return function(req, res, next) {
      var hasSentHeaders, payload, written;
      secret || (secret = req.secret);
      if (!secret) {
        throw new Error("cookieSession:secret_required_in_order_to_encrypt");
      }
      payload = req.cookies[key];
      if (payload) {
        if (noEncrypt) {
          req.session = JSON.parse(payload);
        } else {
          req.session = decryptCookie(payload, type, secret, duration);
        }
      } else {
        req.session = newSession();
      }
      req.sessionID = req.session.id;
      hasSentHeaders = false;
      res._write = res.write;
      res.write = function() {
        var arg;
        arg = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        if (!hasSentHeaders) {
          res.emit('header');
          hasSentHeaders = true;
        }
        return res._write.apply(res, arg);
      };
      res._end = res.end;
      res.end = function() {
        var arg;
        arg = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        if (!hasSentHeaders) {
          res.emit('header');
          hasSentHeaders = true;
        }
        return res._end.apply(res, arg);
      };
      written = false;
      res.on('header', function() {
        var cookie;
        if (!written) {
          cookie = !req.session ? Cookie.serialize(key, '', {
            expires: new Date(0)
          }) : noEncrypt ? Cookie.serialize(key, JSON.stringify(req.session), cookieOptions) : Cookie.serialize(key, encryptCookie(req.session, type, secret), cookieOptions);
          res.setHeader('Set-Cookie', cookie);
          return written = true;
        }
      });
      return next();
    };
  };

  module.exports = cookieSession;

}).call(this);
